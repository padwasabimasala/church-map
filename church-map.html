<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Utah County Churches Map</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <style>#map{height:100vh}</style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script>
// Denomination -> color mapping (adjust as needed)
// Added more granular keys to match values found in the GeoJSON
const denomColors = {
  "LDS": "#9c27b0",
  "Catholic": "#d32f2f",
  "Baptist": "#1976d2",
  "Pentecostal": "#f44336",
  "Non-denominational": "#4caf50",
  "Presbyterian": "#00796b",
  "Episcopal": "#3949ab",
  "Adventist": "#009688",
  "EV Free": "#00bcd4",
  "Iglesia": "#ffb300",
  "Other": "#607d8b"
};

const map = L.map('map').setView([40.3, -111.7], 10); // center Utah County
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 18, attribution: '© OpenStreetMap contributors'
}).addTo(map);

// helper: create a small colored SVG icon as a data URI
// Create a small colored SVG icon as a data URI. Accepts an optional shape:
// 'circle' (default) or 'square'.
function createColoredIcon(color, shape = 'circle'){
  let svgStr;
  // Use 25x25px icons so markers remain clearly visible at all zoom levels.
  if(shape === 'square'){
    // small rounded square
    svgStr = `<svg xmlns="http://www.w3.org/2000/svg" width="25" height="25"><rect x="3" y="3" width="19" height="19" rx="4" ry="4" fill="${color}" stroke="#222" stroke-width="2"/></svg>`;
  } else {
    // circle
    svgStr = `<svg xmlns="http://www.w3.org/2000/svg" width="25" height="25"><circle cx="12.5" cy="11" r="9" fill="${color}" stroke="#222" stroke-width="2"/></svg>`;
  }
  const svg = encodeURIComponent(svgStr);
  const url = `data:image/svg+xml;utf8,${svg}`;
  // iconSize is in pixels and keeps it constant across zoom levels
  return L.icon({iconUrl: url, iconSize: [25,25], iconAnchor: [12,12], popupAnchor: [0,-10]});
}

// Normalise raw denomination values to one of our denomColors keys
function denomKeyFromRaw(rawDenom, rawName) {
  // First, try denomination string
  if (!rawDenom) rawDenom = '';
  const s = String(rawDenom).toLowerCase();
  if (s.includes('catholic') || s.includes('roman')) return 'Catholic';
  if (s.includes('mormon') || s.includes('latter') || s.includes('lds') || s.includes('temple')) return 'LDS';
  if (s.includes('baptist')) return 'Baptist';
  if (s.includes('pentec')) return 'Pentecostal';
  if (s.includes('presbyterian')) return 'Presbyterian';
  if (s.includes('episcopal')) return 'Episcopal';
  if (s.includes('adventist')) return 'Adventist';
  if (s.includes('ev free')) return 'EV Free';
  if (s.includes('iglesia')) return 'Iglesia';
  if (s.includes('non') || s.includes('nondenom') || s.includes('non-denom')) return 'Non-denominational';
  // If denomination is 'Other', try to match by name
  if (rawName === undefined || rawName === null || String(rawName).trim() === "") {
    return "LDS";
  }
  if (rawName) {
    const n = String(rawName).toLowerCase();
    if (n.includes('maranatha christian')) return 'Non-denominational';
    if (n.includes('the rock')) return 'Non-denominational';
    if (n.includes('centerpoint church')) return 'EV Free';
  if (n.includes('catholic') || n.includes('roman')) return 'Catholic';
  if (n.includes('mormon') || n.includes('latter') || n.includes('lds') || n.includes('temple')) return 'LDS';
  if (n.includes('baptist')) return 'Baptist';
  if (n.includes('pentec')) return 'Pentecostal';
  if (n.includes('presbyterian')) return 'Presbyterian';
  if (n.includes('episcopal')) return 'Episcopal';
  if (n.includes('adventist')) return 'Adventist';
  if (n.includes('ev free')) return 'EV Free';
  if (n.includes('iglesia')) return 'Iglesia';
  if (n.includes('bible')) return 'Non-denominational';
  if (n.includes('community')) return 'Non-denominational';
  if (n.includes('non') || n.includes('nondenom') || n.includes('non-denom')) return 'Non-denominational';
  }
  return 'Other';
}

// load GeoJSON and add to a marker cluster group
fetch('churches.geojson').then(r=>r.json()).then(data=>{
  const markers = L.markerClusterGroup();
  // keep arrays of markers per denomination so we can toggle visibility
  const denomMarkers = {};
  for (const k of Object.keys(denomColors)) denomMarkers[k] = [];

  const geo = L.geoJSON(data, {
    pointToLayer: function(feature, latlng){
      const p = feature.properties || {};
        const name = p.name || '';
      // our generator flattens denomination into 'place_of_worship.denomination' sometimes
      const rawDenom = p['place_of_worship.denomination'] || p.denomination || p['denomination'] || '';
      // detect building type for special shapes (e.g., temples)
      const rawBuilding = p['building'] || (feature.properties && feature.properties['building']) || '';
      const buildingType = rawBuilding && typeof rawBuilding === 'object' ? rawBuilding.type || '' : rawBuilding || '';
      const key = denomKeyFromRaw(rawDenom, name);
      const color = denomColors[key] || denomColors['Other'];
      const shape = (String(buildingType).toLowerCase().includes('temple') || String(rawDenom).toLowerCase().includes('temple')) ? 'square' : 'circle';
      const marker = L.marker(latlng, {icon: createColoredIcon(color, shape)});
      // track marker by denomination for toggling
      if (!denomMarkers[key]) denomMarkers[key] = [];
      denomMarkers[key].push(marker);
      return marker;
    },
    onEachFeature: function(feature, layer){
      const p = feature.properties || {};
      const name = p.name || '';
      const addr = p.formatted || p.address_line2 || p.address_line1 || '';
      const phone = p.phone || p.contact || '';
      const website = p.website ? `<a href="${p.website}" target="_blank">website</a>` : '';
      const rawDenom = p['place_of_worship.denomination'] || p.denomination || p['denomination'] || '';
      const denom = denomKeyFromRaw(rawDenom, name);
      const popup = `<strong>${name}</strong><br>${addr}${phone?'<br>Phone: '+phone:''}${website?'<br>'+website:''}<br><em>${denom}</em>`;
      layer.bindPopup(popup);
    }
  });

  markers.addLayer(geo);
  map.addLayer(markers);
  addLegend(markers, denomMarkers);
});

// Population density choropleth layer (populated by fetch_census_data.py)
let popLayer = null;
function addPopulationLayer(){
  fetch('tracts_population.geojson').then(r=>r.json()).then(data=>{
    // color scale (people per km2)
    function getColor(d){
      return d > 2000 ? '#800026' :
             d > 1000 ? '#BD0026' :
             d > 500  ? '#E31A1C' :
             d > 200  ? '#FC4E2A' :
             d > 100  ? '#FD8D3C' :
             d > 50   ? '#FEB24C' :
             d > 10   ? '#FED976' :
                        '#FFEDA0';
    }

    function style(feature){
      const d = feature.properties && feature.properties.density_per_km2 ? feature.properties.density_per_km2 : 0;
      return {fillColor: getColor(d), weight: 1, opacity: 1, color: 'white', fillOpacity: 0.7};
    }

    popLayer = L.geoJSON(data, {style: style, onEachFeature: function(f, layer){
      const p = f.properties || {};
      const name = p.NAME || p.GEOID || '';
      const popup = `<strong>${name}</strong><br>Population: ${p.population||0}<br>Density: ${p.density_per_km2?p.density_per_km2.toFixed(1):'—'} per km²`;
      layer.bindPopup(popup);
    }});

    // Add a simple toggle control to the map (checkbox in legend)
    const legendControl = document.querySelector('.legend');
    if (legendControl){
      const wrapper = document.createElement('div');
      wrapper.style.marginTop = '8px';
      wrapper.innerHTML = `<label style="font-size:13px;display:flex;align-items:center"><input id="pop-toggle" type="checkbox" style="margin-right:6px"> Show population density</label>`;
      legendControl.appendChild(wrapper);
      const cb = document.getElementById('pop-toggle');
      cb.addEventListener('change', function(e){
        if (this.checked) popLayer.addTo(map);
        else map.removeLayer(popLayer);
      });

      // Add population density color legend
      const popLegend = document.createElement('div');
      popLegend.className = 'pop-density-legend';
      popLegend.style.marginTop = '8px';
      popLegend.style.fontSize = '13px';
      popLegend.innerHTML = `
        <div style="margin-bottom:4px;font-weight:bold;">Population Density (per km²)</div>
        <div><span style="background:#800026;width:18px;height:12px;display:inline-block;margin-right:6px;border:1px solid #222;"></span> > 2000</div>
        <div><span style="background:#BD0026;width:18px;height:12px;display:inline-block;margin-right:6px;border:1px solid #222;"></span> 1001–2000</div>
        <div><span style="background:#E31A1C;width:18px;height:12px;display:inline-block;margin-right:6px;border:1px solid #222;"></span> 501–1000</div>
        <div><span style="background:#FC4E2A;width:18px;height:12px;display:inline-block;margin-right:6px;border:1px solid #222;"></span> 201–500</div>
        <div><span style="background:#FD8D3C;width:18px;height:12px;display:inline-block;margin-right:6px;border:1px solid #222;"></span> 101–200</div>
        <div><span style="background:#FEB24C;width:18px;height:12px;display:inline-block;margin-right:6px;border:1px solid #222;"></span> 51–100</div>
        <div><span style="background:#FED976;width:18px;height:12px;display:inline-block;margin-right:6px;border:1px solid #222;"></span> 11–50</div>
        <div><span style="background:#FFEDA0;width:18px;height:12px;display:inline-block;margin-right:6px;border:1px solid #222;"></span> 0–10</div>
        <div id="pop-legend-total" style="margin-top:8px;font-weight:bold;color:#222">Visible Population: —</div>
      `;
      legendControl.appendChild(popLegend);

      // Function to update visible population
      function updateVisiblePopulation() {
        if (!popLayer || typeof popLayer.getLayers !== 'function') {
          document.getElementById('pop-legend-total').innerText = 'Visible Population: —';
          return;
        }
        const bounds = map.getBounds();
        let total = 0;
        popLayer.eachLayer(function(layer) {
          if (layer.getLatLng) return; // skip point layers
          const feature = layer.feature;
          if (!feature || !feature.geometry) return;
          // Only count polygons that intersect the map bounds
          try {
            const geojson = feature;
            // Simple bbox check for polygons
            const coords = geojson.geometry.coordinates;
            if (!coords) return;
            // For MultiPolygon or Polygon
            let inView = false;
            function checkPoly(poly) {
              for (const ring of poly) {
                for (const pt of ring) {
                  const lat = pt[1], lng = pt[0];
                  if (bounds.contains([lat, lng])) {
                    inView = true;
                    return;
                  }
                }
              }
            }
            if (geojson.geometry.type === 'Polygon') {
              checkPoly(coords);
            } else if (geojson.geometry.type === 'MultiPolygon') {
              for (const poly of coords) checkPoly(poly);
            }
            if (inView) {
              const pop = layer.feature.properties && layer.feature.properties.population;
              if (typeof pop === 'number') total += pop;
            }
          } catch(e) {}
        });
        document.getElementById('pop-legend-total').innerText = 'Visible Population: ' + total.toLocaleString();
      }
      // Update on map move/zoom
      map.on('moveend zoomend', updateVisiblePopulation);
      // Initial call
      setTimeout(updateVisiblePopulation, 500);
    }

  }).catch(err=>{
    console.warn('Population GeoJSON not found or failed to load:', err);
  });
}

// try to load if file exists (best-effort)
fetch('tracts_population.geojson', {method: 'HEAD'}).then(r=>{ if (r.ok) addPopulationLayer(); }).catch(()=>{});

// Simple legend
function addLegend(markers, denomMarkers){
  const legend = L.control({position:'topright'});
  legend.onAdd = function() {
    const div = L.DomUtil.create('div','info legend');
  div.style.maxHeight = '80vh';
    div.style.overflowY = 'auto';
    for (const k of Object.keys(denomColors)) {
      const color = denomColors[k];
      const count = denomMarkers[k] ? denomMarkers[k].length : 0;
      const item = document.createElement('div');
      item.className = 'legend-item';
      item.style.cursor = 'pointer';
      item.style.marginBottom = '6px';
      item.innerHTML = `<i data-key="${k}" style="background:${color};width:14px;height:14px;display:inline-block;margin-right:6px;border:1px solid #222;vertical-align:middle"></i><span style="vertical-align:middle">${k}</span> <span style="color:#444;font-size:12px;margin-left:4px">(${count})</span>`;
      // default visible
      item.dataset.visible = '1';

      // click toggles visibility
      L.DomEvent.on(item, 'click', function(e){
        const key = this.querySelector('i').dataset.key;
        const visible = this.dataset.visible === '1';
        if (visible){
          // hide: remove each marker from cluster group
          const list = denomMarkers[key] || [];
          for (const m of list) markers.removeLayer(m);
          this.dataset.visible = '0';
          this.style.opacity = '0.45';
        } else {
          const list = denomMarkers[key] || [];
          for (const m of list) markers.addLayer(m);
          this.dataset.visible = '1';
          this.style.opacity = '1';
        }
        // update visible count after toggling
        if (typeof updateVisibleCount === 'function') updateVisibleCount();
      });

      L.DomEvent.disableClickPropagation(item);
      div.appendChild(item);
    }
    // footer: visible count
    const footer = document.createElement('div');
    footer.id = 'legend-count';
    footer.style.marginTop = '8px';
    footer.style.fontWeight = 'bold';
    footer.innerText = 'Visible: 0';
    div.appendChild(footer);

    // update function to reflect number of markers currently in the cluster group
    function updateVisibleCount(){
      try{
        if (!markers || typeof markers.getLayers !== 'function') {
          footer.innerText = 'Visible: 0';
          return;
        }
        const layers = markers.getLayers();
        // count only markers that are inside the current map bounds
        const bounds = map && typeof map.getBounds === 'function' ? map.getBounds() : null;
        let count = 0;
        for (const m of layers){
          try{
            if (!bounds) { count++; continue; }
            const latlng = (m && typeof m.getLatLng === 'function') ? m.getLatLng() : null;
            if (latlng && bounds.contains(latlng)) count++;
          }catch(err){ /* ignore individual marker errors */ }
        }
        footer.innerText = 'Visible: ' + count;
      }catch(e){
        footer.innerText = 'Visible: —';
      }
    }

    // call once initially
    setTimeout(updateVisibleCount, 100);

    // update when toggles occur by listening to clicks (we already call updateVisibleCount there)
    // also update on map move/zoom in case markers change
    map.on('moveend zoomend', updateVisibleCount);

    return div;
  };
  legend.addTo(map);
}

// small CSS tweak for legend items
const style = document.createElement('style');
style.innerHTML = `.legend .legend-item{font-family:Arial,Helvetica,sans-serif;font-size:13px}`;
document.head.appendChild(style);
</script>
</body>
</html>

